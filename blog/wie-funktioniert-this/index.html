<!DOCTYPE html><html lang="de"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="theme-color" content="#243342"><meta name="description" content="this ist eine der am meisten missverstandenen Funktionen von JavaScript. Hier möchte ich etwas Licht ins Dunkel bringen."><title>Wie funktioniert &quot;this&quot; in JavaScript? ‒ Linnert Media</title><link rel="stylesheet" href="/styles.css"></head><body><div class="article-page-header"><div class="article-page-header__top-bar"><div class="article-page-header__logo"><a href="/"><div class="dark-logo"><div class="dark-logo__part-a">linnert</div><div class="dark-logo__part-b">media</div></div></a></div><div class="main-navigation main-navigation--type-dark"><ul class="main-navigation__items"><li class="main-navigation__item"><a href="/" class="main-navigation__item-link">Beiträge</a></li><li class="main-navigation__item"><a href="/blog" class="main-navigation__item-link">Blog-FAQ</a></li><li class="main-navigation__item"><a href="/autor" class="main-navigation__item-link">Autor</a></li></ul></div></div><div class="article-page-header__metadata">17.02.2019 /&nbsp;<div class="article-page-header__topline"><a class="tag-link tag-link--type-javascript" href="/blog/tag/javascript">JavaScript</a></div></div><h1 class="article-page-header__title">Wie funktioniert &quot;this&quot; in JavaScript?</h1><svg class="article-page-header__graphic" viewBox="0 0 500 50" preserveAspectRatio="none"><path d="M0,0l0,50c63.994,-32.923 149.576,-35.395 263,-25c121.314,11.118 173.166,4.433 237,-25l-500,0Z" style="fill:#2d4053;"/></svg></div><article class="article-content"><p>Das Keyword <code>this</code> in JavaScript ist eines der am meisten missverstandenen Sprachfeatures. Die Verwirrung rührt in der Regel daher, dass es in anderen Sprachen ebenfalls ein <code>this</code>-Keyword gibt, mit einer scheinbar ähnlichen Funktionsweise. Oft wird davon abgeraten, <code>this</code> überhaupt zu verwenden. Ich möchte in diesem Artikel die Angst vor dem Schlüsselwort nehmen und erklären, wie es genau funktioniert.</p><p>Andere klassenbasierte Sprachen ‒ z. B. Java ‒ verwenden <code>this</code>, um auf die aktuelle Instanz einer Klasse zu verweisen. Schaut man jetzt zu JavaScript, stellt man fest, dass es hier keine Klassen gibt. Dadurch ist es für JavaScript gar nicht möglich, <code>this</code> genauso zu implementieren wie Java es tut. Es wurde mit ECMAScript 2015 zwar das Keyword <code>class</code> eingeführt, aber eine Garantie, dass <code>this</code> <strong>immer</strong> auf die Instanz dieser Klasse zeigt, ist auch hier nicht gegeben. Dadurch wird verhindert, dass neue Sonderregelungen und Abweichungen von der bisherigen Funktionsweise in die Sprache Einzug erhalten.</p><p>Doch wie funktioniert <code>this</code> nun genau? Man stellt sich <code>this</code> am besten als eine Art <em>nullten</em> (noch vor dem zuerst platzierten), impliziten Funktionsparameter vor. Dieser wird ebenfalls implizit an eine Funktion übergeben, man kann ihn aber auch explizit angeben.</p><h2>Implizite Belegung von <code>this</code></h2><p>Wann wird <code>this</code> implizit an eine Funktion übergeben? Bei jedem einzelnen Funktionsaufruf. Was ist der Wert von <code>this</code>? Das Objekt, über das die Funktion aufgerufen wird. Ob <code>this</code> mit einem Wert belegt wird und mit welchem Wert es belegt wird, hängt also vollständig davon ab, wie der Funktionsaufruf exakt aussieht. Wird eine Funktion als reine Funktion aufgerufen, hängt der Wert von <code>this</code> davon ab, ob das Skript im &quot;strict&quot; mode läuft, oder nicht. Hier ein paar Beispiele:</p><pre class="language-js"><code class="language-js"><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// innerhalb von foo:</span>
<span class="token comment">// ("strict" mode ist aus) this === window</span>
<span class="token comment">// ("strict" mode ist an) this === undefined</span>

foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// innerhalb von bar → this === foo</span>
foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// innerhalb von baz → this === foo.bar</span>
</code></pre><p>Dieses Verhalten ändert sich nicht, wenn man Funktionen nimmt und sie anderen Variablen oder Eigenschaften zuweist.</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">outerFunction</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">innerFunction</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> window|undefined</span>
obj1<span class="token punctuation">.</span><span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> obj1</span>

obj1<span class="token punctuation">.</span>outerFunction <span class="token operator">=</span> outerFunction
obj1<span class="token punctuation">.</span><span class="token function">outerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> obj1</span>

<span class="token keyword">const</span> innerFunction <span class="token operator">=</span> obj1<span class="token punctuation">.</span>innerFunction
<span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> window|undefined</span>

obj2<span class="token punctuation">.</span>innerFunction <span class="token operator">=</span> obj1<span class="token punctuation">.</span>innerFunction
obj2<span class="token punctuation">.</span><span class="token function">innerFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> obj2</span>
</code></pre><h2>Explizite Belegung von <code>this</code></h2><p>Man kann auch explizit einen Wert für <code>this</code> angeben. Man spricht hier von <em>binding</em>. Dazu benötigen wir eine von 3 Methoden, die jedes Funktionsobjekt besitzt. Wir erinnern uns: Auch Funktionen sind Objekte. Die einfachste Möglichkeit ist die <code>.call</code>-Methode. Diese verwendet man so:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Max'</span><span class="token punctuation">,</span>
  <span class="token function">greetUser</span> <span class="token punctuation">(</span><span class="token parameter">greeting<span class="token punctuation">,</span> suffix</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting <span class="token operator">+</span> <span class="token string">', '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> suffix<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Egon'</span> <span class="token punctuation">}</span>

user<span class="token punctuation">.</span><span class="token function">greetUser</span><span class="token punctuation">(</span><span class="token string">'Hallo'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token comment">// -> 'Hallo, Max.'</span>
user<span class="token punctuation">.</span><span class="token function">greetUser</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>user2<span class="token punctuation">,</span> <span class="token string">'Moin'</span><span class="token punctuation">,</span> <span class="token string">'!'</span><span class="token punctuation">)</span> <span class="token comment">// -> 'Moin, Egon!'</span>
</code></pre><p>Bei dieser Methodik sieht man auch wunderbar die Parameter-Natur von <code>this</code>. Der Wert von <code>this</code> wird als erstes an die <code>.call</code>-Methode übergeben, die sonst für eine Funktion üblichen Parameter rücken eine Stelle weiter nach hinten.</p><p>Des weiteren gibt es noch die <code>.apply</code>-Methode. Diese Funktioniert im Prinzip genauso, mit der Ausnahme, dass die Parameter für die aufgerufene Funktion nicht einzeln, sondern als Array übergeben werden. Dies ist auch eine beliebte Methode, um Funktionen zu erstellen, die beliebig viele Parameter annehmen. Hier ein Beispiel:</p><pre class="language-js"><code class="language-js">user<span class="token punctuation">.</span><span class="token function">gridUser</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>user2<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Moin'</span><span class="token punctuation">,</span> <span class="token string">'!'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>Zuletzt gibt es noch die dritte Methode <code>.bind</code>. Diese ruft, anders als <code>.call</code> und <code>.apply</code> die Funktion nicht direkt auf, sondern liefert lediglich eine veränderte Variante der Funktion zurück, in der der Wert von <code>this</code> bereits festgesetzt ist. Dies ist hilfreich, wenn man eine Referenz auf eine Funktion an eine andere Funktion übergeben möchte, man aber den Wert von <code>this</code> innerhalb der übergebenen Funktion festlegen möchte. Hier ein simples Basisbeispiel:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">logValue</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span>

<span class="token keyword">const</span> logValueOfObj <span class="token operator">=</span> <span class="token function">logValue</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token function">logValueOfObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// -> 42</span>
</code></pre><p>Ist eine Funktion einmal an einen Wert für <code>this</code> gebunden, kann dieser durch nichts mehr geändert werden.</p><p>Ein gutes Praxisbeispiel hierfür ist das Setzen eines EventListeners:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token function">onBodyClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/* 2 */</span>

    <span class="token keyword">function</span> <span class="token function">onBodyClick</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">/* 3 */</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* 1 */</span>
</code></pre><p><em>Erklärung:</em> Alles beginnt mit dem Funktionsaufruf <code>obj.main()</code> bei <code>/* 1 */</code>. Dadurch wird der Wert von <code>this</code> innerhalb der <code>main</code>-Funktion auf <code>obj</code> festgelegt. Beim Setzen des EventListeners bei <code>/* 2 */</code> wird der Wert von <code>this</code> innerhalb der <code>onBodyClick</code>-Funktion auf das aktuelle <code>this</code> gesetzt, also <code>obj</code>. Damit (und nur damit) hat auch <code>onBodyClick</code> bei <code>/* 3 */</code> Zugriff auf <code>obj</code> über <code>this</code>.</p><p>Warum ist das notwendig? Das liegt an der Natur von Callbacks und sieht man schön an einem erweiterten Beispiel:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getSomeData</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">doMagicStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">handler</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">/* 2 */</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">getSomeData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>gotSomeData<span class="token punctuation">)</span> <span class="token comment">/* 1 */</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">gotSomeData</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data <span class="token comment">/* 3 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p><em>Erklärung:</em> Auch wenn die Funktionsreferenz zu <code>gotSomeData</code> bei <code>/* 1 */</code> noch eine Verbindung zu <code>this</code> hat, wird sie in <code>getSomeData</code> als Funktionsparameter <code>handler</code> angenommen. Diese verhalten sich ähnlich wie Variablen oder reine Funktionen. Der Aufruf von <code>gotSomeData</code> bzw. <code>handler</code> bei <code>/* 2 */</code> geschieht somit nicht mehr als Methode von <code>this</code>, sondern als normale Funktion. Dadurch besitzt <code>this</code> nach diesem Aufruf bei <code>/* 3 */</code> (im &quot;strict&quot; mode) keinen Wert. Das bedeutet widerum, dass obiger Code bei <code>/* 3 */</code> einen Fehler werfen wird, da, durch die Art und Weise, wie <code>gotSomeData</code> aufgerufen wird, <code>this</code> in dieser Funktion keinen Wert besitzt.</p><p>Verwendet man hier jetzt nicht den &quot;strict&quot; mode von JavaScript, würde man eine Property <code>data</code> im globalen <code>window</code>-Objekt erzeugen und mit dem Wert von <code>data</code> belegen. Das würde zu keinem direkten Fehler, aber potentiell zu einen schwer auffindbaren Bug führen. <em>Also merke:</em> <strong>Immer</strong> den &quot;strict&quot; mode verwenden!</p><p>Übergibt man bei <code>/* 1 */</code> die Callback-Funktion nun nicht als <code>this.gotSomeData</code>, sondern als <code>this.gotSomeData.bind(this)</code>, wird diese Funktion garantiert so aufgerufen, dass <code>this</code> mit dem erwarteten Wert von <code>obj</code> belegt ist.</p><p><em>Übrigens</em>: <code>this.gotSomeData.bind(obj)</code> würde auch funktionieren. Es würde nur dann einen Unterschied machen, wenn <code>obj.main</code> mit einem alternativen Wert für <code>this</code> aufgerufen wird. Wann was sinnvoll ist, ist zu 100% situationsabhängig.</p><h2><code>this</code> und Arrow Functions</h2><p>Die mit ECMAScript 2015 eingeführten <em>Arrow Functions</em> verhalten sich ein klein wenig anders. Diese neuen Gefährten übernehmen automatisch den Wert <code>this</code>, der auch um sie herum bereits gilt. Das Beispiel von weiter oben funktioniert also problemlos, wenn man von Arrow Functions folgendermaßen Gebrauch macht:</p><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">getSomeData</span> <span class="token punctuation">(</span><span class="token parameter">handler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">doMagicStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">handler</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">/* 2 */</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">getSomeData</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">gotSomeData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">/* 1 */</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">gotSomeData</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data <span class="token comment">/* 3 */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p><em>Erklärung:</em> Bei <code>/* 1 */</code> wird nicht direkt die Funktion <code>gotSomeData</code> übergeben, sondern eine Arrow Function. Der Wert von <code>this</code> innerhalb dieser Funktion wird von außen übernommen, zeigt also immer noch auf <code>obj</code>. Bei <code>/* 2 */</code> wird diese neue Arrow Funktion aufgerufen, statt wie bisher direkt <code>gotSomeData</code>. Diese widerum ruft <code>gotSomeData</code> als Methode von <code>this</code> (also <code>obj</code>) auf. Damit ist der Wert von <code>this</code> immerhalb von <code>gotSomeData</code> immer noch <code>obj</code>.</p><h2>Der Typ von <code>this</code></h2><p>Zu guter Letzt noch ein Hinweis: Der Typ von <code>this</code> ist <strong>immer</strong> <code>object</code> oder <code>function</code>. Wird versucht, eine Funktion an einen anderen Wert zu binden, wird dieser Wert in ein Objekt gecastet. Aus <code>1</code> wird also <code>new Number(1)</code>. Diese Objekt-Varianten von simplen Datentypen werden von JavaScript intern immer wieder verwendet, wenn dies notwendig ist. Als JS-Entwickler braucht man sich aber nicht weiter darum kümmern, da es keine nennenswerten Auswirkungen hat.</p></article></body></html>