<!doctype html><html lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linnert Media</title><meta name=theme-color content="#155E75"><link rel=manifest href=/manifest.webmanifest><link rel="shortcut icon" href=/appicons/appicon-16.png sizes=16x16 type=image/png><link rel="shortcut icon" href=/appicons/appicon-32.png sizes=32x32 type=image/png><link rel=icon href=/favicon.ico type=image/x-icon><link rel=stylesheet href=https://linnertmedia.de/css/main.min.8f03dc5cf078700b26823e22c8ad03401f058f87460812e5104276b142f26a8556118304f104e743b5776d8d4eab9e5d2a53c27c979c3cd9cecdee11bff5ba81.css integrity="sha512-jwPcXPB4cAsmgj4iyK0DQB8Fj4dGCBLlEEJ2sULyaoVWEYME8QTnQ7V3bY1Oq55dKlPCfJecPNnOze4Rv/W6gQ==" crossorigin=anonymous></head><body><div class="min-h-screen dark:bg-gray-700"><div class="py-4 lg:py-3 bg-brand-700 text-white sticky sm:static top-0 z-40 dark:bg-gray-800"><div class="max-w-3xl mx-auto px-4 flex items-center justify-center"><a href=https://linnertmedia.de class="font-heading text-2xl lg:text-lg tracking-widest uppercase"><span class="text-brand-200 relative -top-1">Linnert</span><span class="text-brand-50 relative -bottom-1">Media</span></a><div class="hidden sm:hidden ml-auto text-brand-50 hover:text-brand-200"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div><nav class="ml-auto flex gap-6 sm:fixed sm:bottom-0 sm:left-0 sm:right-0 md:flex sm:z-50"><ul class="list-none grid grid-flow-col auto-cols-max sm:auto-cols-fr gap-x-4 sm:gap-x-0 md:flex-grow sm:bg-gray-100 sm:border-t sm:border-gray-300 sm:dark:bg-gray-800 sm:dark:border-gray-500"><li class="sm:flex-grow sm:text-center"><a href=/ class="text-brand-50
sm:block sm:py-2 sm:text-xs sm:font-semibold
outline-none
focus:bg-gray-200
dark:focus:bg-gray-900
sm:text-gray-500
sm:hover:text-gray-600
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg></div><span>Beiträge</span></a></li><li class="sm:flex-grow sm:text-center"><a href=/projekte/ class="text-brand-50
sm:block sm:py-2 sm:text-xs sm:font-semibold
outline-none
focus:bg-gray-200
dark:focus:bg-gray-900
sm:text-gray-500
sm:hover:text-gray-600
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-code"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div><span>Projekte</span></a></li><li class="sm:flex-grow sm:text-center"><a href=/info/ class="text-brand-50
sm:block sm:py-2 sm:text-xs sm:font-semibold
outline-none
focus:bg-gray-200
dark:focus:bg-gray-900
sm:text-gray-500
sm:hover:text-gray-600
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg></div><span>Infos</span></a></li><li class="sm:flex-grow sm:text-center"><a href=/einstellungen/ class="text-brand-50
sm:block sm:py-2 sm:text-xs sm:font-semibold
outline-none
focus:bg-gray-200
dark:focus:bg-gray-900
sm:text-gray-500
sm:hover:text-gray-600
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-settings"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65.0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83.0l-.06-.06a1.65 1.65.0 00-1.82-.33 1.65 1.65.0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65.0 009 19.4a1.65 1.65.0 00-1.82.33l-.06.06a2 2 0 01-2.83.0 2 2 0 010-2.83l.06-.06a1.65 1.65.0 00.33-1.82 1.65 1.65.0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65.0 004.6 9a1.65 1.65.0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83.0l.06.06a1.65 1.65.0 001.82.33H9a1.65 1.65.0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65.0 001 1.51 1.65 1.65.0 001.82-.33l.06-.06a2 2 0 012.83.0 2 2 0 010 2.83l-.06.06a1.65 1.65.0 00-.33 1.82V9a1.65 1.65.0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65.0 00-1.51 1z"/></svg></div><span>Einstellungen</span></a></li></ul></nav></div></div><main class="max-w-3xl mx-auto pb-20"><article class=mt-8><h1 class="font-heading text-3xl mb-2 px-4 dark:text-gray-50">Wie funktioniert this in JavaScript?</h1><div class="mb-8 mx-4"><div class="text-sm md:text-xs flex"><div class="text-gray-500 dark:text-gray-400">17. February 2019</div><a href=/tags/javascript class="link--default ml-4">JavaScript</a></div></div><div class="px-4 text-gray-700 prose prose-lg dark:prose-dark max-w-none"><p>Das Keyword <code>this</code> in JavaScript ist eines der am meisten missverstandenen Sprachfeatures. Die Verwirrung rührt in der Regel daher, dass es in anderen Sprachen ebenfalls ein <code>this</code>-Keyword gibt, mit einer scheinbar ähnlichen Funktionsweise. Oft wird davon abgeraten, <code>this</code> überhaupt zu verwenden. Ich möchte in diesem Artikel die Angst vor dem Schlüsselwort nehmen und erklären, wie es genau funktioniert.</p><p>Andere klassenbasierte Sprachen ‒ z. B. Java ‒ verwenden <code>this</code>, um auf die aktuelle Instanz einer Klasse zu verweisen. Schaut man jetzt zu JavaScript, stellt man fest, dass es hier keine Klassen gibt. Dadurch ist es für JavaScript gar nicht möglich, <code>this</code> genauso zu implementieren wie Java es tut. Es wurde mit ECMAScript 2015 zwar das Keyword <code>class</code> eingeführt, aber eine Garantie, dass <code>this</code> <strong>immer</strong> auf die Instanz dieser Klasse zeigt, ist auch hier nicht gegeben. Dadurch wird verhindert, dass neue Sonderregelungen und Abweichungen von der bisherigen Funktionsweise in die Sprache Einzug erhalten.</p><p>Doch wie funktioniert <code>this</code> nun genau? Man stellt sich <code>this</code> am besten als eine Art <em>nullten</em> (noch vor dem zuerst platzierten), impliziten Funktionsparameter vor. Dieser wird ebenfalls implizit an eine Funktion übergeben, man kann ihn aber auch explizit angeben.</p><h2 id=implizite-belegung-von-this>Implizite Belegung von <code>this</code></h2><p>Wann wird <code>this</code> implizit an eine Funktion übergeben? Bei jedem einzelnen Funktionsaufruf. Was ist der Wert von <code>this</code>? Das Objekt, über das die Funktion aufgerufen wird. Ob <code>this</code> mit einem Wert belegt wird und mit welchem Wert es belegt wird, hängt also vollständig davon ab, wie der Funktionsaufruf exakt aussieht. Wird eine Funktion als reine Funktion aufgerufen, hängt der Wert von <code>this</code> davon ab, ob das Skript im &ldquo;strict&rdquo; mode läuft, oder nicht. Hier ein paar Beispiele:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>foo</span><span class=p>()</span>
<span class=c1>// innerhalb von foo:
</span><span class=c1>// (&#34;strict&#34; mode ist aus) this === window
</span><span class=c1>// (&#34;strict&#34; mode ist an) this === undefined
</span><span class=c1></span>
<span class=nx>foo</span><span class=p>.</span><span class=nx>bar</span><span class=p>()</span> <span class=c1>// innerhalb von bar → this === foo
</span><span class=c1></span><span class=nx>foo</span><span class=p>.</span><span class=nx>bar</span><span class=p>.</span><span class=nx>baz</span><span class=p>()</span> <span class=c1>// innerhalb von baz → this === foo.bar
</span></code></pre></div><p>Dieses Verhalten ändert sich nicht, wenn man Funktionen nimmt und sie anderen Variablen oder Eigenschaften zuweist.</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>outerFunction</span> <span class=p>()</span> <span class=p>{</span>
  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>obj1</span> <span class=o>=</span> <span class=p>{</span>
  <span class=nx>innerFunction</span> <span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>obj2</span> <span class=o>=</span> <span class=p>{}</span>

<span class=nx>outerFunction</span><span class=p>()</span> <span class=c1>// -&gt; window|undefined
</span><span class=c1></span><span class=nx>obj1</span><span class=p>.</span><span class=nx>innerFunction</span><span class=p>()</span> <span class=c1>// -&gt; obj1
</span><span class=c1></span>
<span class=nx>obj1</span><span class=p>.</span><span class=nx>outerFunction</span> <span class=o>=</span> <span class=nx>outerFunction</span>
<span class=nx>obj1</span><span class=p>.</span><span class=nx>outerFunction</span><span class=p>()</span> <span class=c1>// -&gt; obj1
</span><span class=c1></span>
<span class=kr>const</span> <span class=nx>innerFunction</span> <span class=o>=</span> <span class=nx>obj1</span><span class=p>.</span><span class=nx>innerFunction</span>
<span class=nx>innerFunction</span><span class=p>()</span> <span class=c1>// -&gt; window|undefined
</span><span class=c1></span>
<span class=nx>obj2</span><span class=p>.</span><span class=nx>innerFunction</span> <span class=o>=</span> <span class=nx>obj1</span><span class=p>.</span><span class=nx>innerFunction</span>
<span class=nx>obj2</span><span class=p>.</span><span class=nx>innerFunction</span><span class=p>()</span> <span class=c1>// -&gt; obj2
</span></code></pre></div><h2 id=explizite-belegung-von-this>Explizite Belegung von <code>this</code></h2><p>Man kann auch explizit einen Wert für <code>this</code> angeben. Man spricht hier von <em>binding</em>. Dazu benötigen wir eine von 3 Methoden, die jedes Funktionsobjekt besitzt. Wir erinnern uns: Auch Funktionen sind Objekte. Die einfachste Möglichkeit ist die <code>.call</code>-Methode. Diese verwendet man so:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=p>{</span>
  <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Max&#39;</span><span class=p>,</span>
  <span class=nx>greetUser</span> <span class=p>(</span><span class=nx>greeting</span><span class=p>,</span> <span class=nx>suffix</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>greeting</span> <span class=o>+</span> <span class=s1>&#39;, &#39;</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>name</span> <span class=o>+</span> <span class=nx>suffix</span><span class=p>)</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>user2</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Egon&#39;</span> <span class=p>}</span>

<span class=nx>user</span><span class=p>.</span><span class=nx>greetUser</span><span class=p>(</span><span class=s1>&#39;Hallo&#39;</span><span class=p>,</span> <span class=s1>&#39;.&#39;</span><span class=p>)</span> <span class=c1>// -&gt; &#39;Hallo, Max.&#39;
</span><span class=c1></span><span class=nx>user</span><span class=p>.</span><span class=nx>greetUser</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>user2</span><span class=p>,</span> <span class=s1>&#39;Moin&#39;</span><span class=p>,</span> <span class=s1>&#39;!&#39;</span><span class=p>)</span> <span class=c1>// -&gt; &#39;Moin, Egon!&#39;
</span></code></pre></div><p>Bei dieser Methodik sieht man auch wunderbar die Parameter-Natur von <code>this</code>. Der Wert von <code>this</code> wird als erstes an die <code>.call</code>-Methode übergeben, die sonst für eine Funktion üblichen Parameter rücken eine Stelle weiter nach hinten.</p><p>Des weiteren gibt es noch die <code>.apply</code>-Methode. Diese Funktioniert im Prinzip genauso, mit der Ausnahme, dass die Parameter für die aufgerufene Funktion nicht einzeln, sondern als Array übergeben werden. Dies ist auch eine beliebte Methode, um Funktionen zu erstellen, die beliebig viele Parameter annehmen. Hier ein Beispiel:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>user</span><span class=p>.</span><span class=nx>gridUser</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=nx>user2</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;Moin&#39;</span><span class=p>,</span> <span class=s1>&#39;!&#39;</span><span class=p>])</span>
</code></pre></div><p>Zuletzt gibt es noch die dritte Methode <code>.bind</code>. Diese ruft, anders als <code>.call</code> und <code>.apply</code> die Funktion nicht direkt auf, sondern liefert lediglich eine veränderte Variante der Funktion zurück, in der der Wert von <code>this</code> bereits festgesetzt ist. Dies ist hilfreich, wenn man eine Referenz auf eine Funktion an eine andere Funktion übergeben möchte, man aber den Wert von <code>this</code> innerhalb der übergebenen Funktion festlegen möchte. Hier ein simples Basisbeispiel:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>logValue</span> <span class=p>()</span> <span class=p>{</span>
  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>value</span><span class=p>)</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>value</span><span class=o>:</span> <span class=mi>42</span> <span class=p>}</span>

<span class=kr>const</span> <span class=nx>logValueOfObj</span> <span class=o>=</span> <span class=nx>logValue</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>obj</span><span class=p>)</span>
<span class=nx>logValueOfObj</span><span class=p>()</span> <span class=c1>// -&gt; 42
</span></code></pre></div><p>Ist eine Funktion einmal an einen Wert für <code>this</code> gebunden, kann dieser durch nichts mehr geändert werden.</p><p>Ein gutes Praxisbeispiel hierfür ist das Setzen eines EventListeners:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kr>const</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span>
  <span class=nx>main</span> <span class=p>()</span> <span class=p>{</span>
    <span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;click&#39;</span><span class=p>,</span> <span class=nx>onBodyClick</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=k>this</span><span class=p>))</span> <span class=cm>/* 2 */</span>

    <span class=kd>function</span> <span class=nx>onBodyClick</span> <span class=p>()</span> <span class=p>{</span>
      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>)</span> <span class=cm>/* 3 */</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=nx>obj</span><span class=p>.</span><span class=nx>main</span><span class=p>()</span> <span class=cm>/* 1 */</span>
</code></pre></div><p><em>Erklärung:</em> Alles beginnt mit dem Funktionsaufruf <code>obj.main()</code> bei <code>/* 1 */</code>. Dadurch wird der Wert von <code>this</code> innerhalb der <code>main</code>-Funktion auf <code>obj</code> festgelegt. Beim Setzen des EventListeners bei <code>/* 2 */</code> wird der Wert von <code>this</code> innerhalb der <code>onBodyClick</code>-Funktion auf das aktuelle <code>this</code> gesetzt, also <code>obj</code>. Damit (und nur damit) hat auch <code>onBodyClick</code> bei <code>/* 3 */</code> Zugriff auf <code>obj</code> über <code>this</code>.</p><p>Warum ist das notwendig? Das liegt an der Natur von Callbacks und sieht man schön an einem erweiterten Beispiel:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>getSomeData</span> <span class=p>(</span><span class=nx>handler</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>doMagicStuff</span><span class=p>()</span>
  <span class=nx>handler</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=cm>/* 2 */</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span>
  <span class=nx>main</span> <span class=p>()</span> <span class=p>{</span>
    <span class=nx>getSomeData</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>gotSomeData</span><span class=p>)</span> <span class=cm>/* 1 */</span>
  <span class=p>},</span>

  <span class=nx>gotSomeData</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>data</span> <span class=o>=</span> <span class=nx>data</span> <span class=cm>/* 3 */</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=nx>obj</span><span class=p>.</span><span class=nx>main</span><span class=p>()</span>
</code></pre></div><p><em>Erklärung:</em> Auch wenn die Funktionsreferenz zu <code>gotSomeData</code> bei <code>/* 1 */</code> noch eine Verbindung zu <code>this</code> hat, wird sie in <code>getSomeData</code> als Funktionsparameter <code>handler</code> angenommen. Diese verhalten sich ähnlich wie Variablen oder reine Funktionen. Der Aufruf von <code>gotSomeData</code> bzw. <code>handler</code> bei <code>/* 2 */</code> geschieht somit nicht mehr als Methode von <code>this</code>, sondern als normale Funktion. Dadurch besitzt <code>this</code> nach diesem Aufruf bei <code>/* 3 */</code> (im &ldquo;strict&rdquo; mode) keinen Wert. Das bedeutet widerum, dass obiger Code bei <code>/* 3 */</code> einen Fehler werfen wird, da, durch die Art und Weise, wie <code>gotSomeData</code> aufgerufen wird, <code>this</code> in dieser Funktion keinen Wert besitzt.</p><p>Verwendet man hier jetzt nicht den &ldquo;strict&rdquo; mode von JavaScript, würde man eine Property <code>data</code> im globalen <code>window</code>-Objekt erzeugen und mit dem Wert von <code>data</code> belegen. Das würde zu keinem direkten Fehler, aber potentiell zu einen schwer auffindbaren Bug führen. <em>Also merke:</em> <strong>Immer</strong> den &ldquo;strict&rdquo; mode verwenden!</p><p>Übergibt man bei <code>/* 1 */</code> die Callback-Funktion nun nicht als <code>this.gotSomeData</code>, sondern als <code>this.gotSomeData.bind(this)</code>, wird diese Funktion garantiert so aufgerufen, dass <code>this</code> mit dem erwarteten Wert von <code>obj</code> belegt ist.</p><p><em>Übrigens</em>: <code>this.gotSomeData.bind(obj)</code> würde auch funktionieren. Es würde nur dann einen Unterschied machen, wenn <code>obj.main</code> mit einem alternativen Wert für <code>this</code> aufgerufen wird. Wann was sinnvoll ist, ist zu 100% situationsabhängig.</p><h2 id=this-und-arrow-functions><code>this</code> und Arrow Functions</h2><p>Die mit ECMAScript 2015 eingeführten <em>Arrow Functions</em> verhalten sich ein klein wenig anders. Diese neuen Gefährten übernehmen automatisch den Wert <code>this</code>, der auch um sie herum bereits gilt. Das Beispiel von weiter oben funktioniert also problemlos, wenn man von Arrow Functions folgendermaßen Gebrauch macht:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=kd>function</span> <span class=nx>getSomeData</span> <span class=p>(</span><span class=nx>handler</span><span class=p>)</span> <span class=p>{</span>
  <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=nx>doMagicStuff</span><span class=p>()</span>
  <span class=nx>handler</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=cm>/* 2 */</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span>
  <span class=nx>main</span> <span class=p>()</span> <span class=p>{</span>
    <span class=nx>getSomeData</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=k>this</span><span class=p>.</span><span class=nx>gotSomeData</span><span class=p>()</span> <span class=p>})</span> <span class=cm>/* 1 */</span>
  <span class=p>},</span>

  <span class=nx>gotSomeData</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>data</span> <span class=o>=</span> <span class=nx>data</span> <span class=cm>/* 3 */</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=nx>obj</span><span class=p>.</span><span class=nx>main</span><span class=p>()</span>
</code></pre></div><p><em>Erklärung:</em> Bei <code>/* 1 */</code> wird nicht direkt die Funktion <code>gotSomeData</code> übergeben, sondern eine Arrow Function. Der Wert von <code>this</code> innerhalb dieser Funktion wird von außen übernommen, zeigt also immer noch auf <code>obj</code>. Bei <code>/* 2 */</code> wird diese neue Arrow Funktion aufgerufen, statt wie bisher direkt <code>gotSomeData</code>. Diese widerum ruft <code>gotSomeData</code> als Methode von <code>this</code> (also <code>obj</code>) auf. Damit ist der Wert von <code>this</code> immerhalb von <code>gotSomeData</code> immer noch <code>obj</code>.</p><h2 id=der-typ-von-this>Der Typ von <code>this</code></h2><p>Zu guter Letzt noch ein Hinweis: Der Typ von <code>this</code> ist <strong>immer</strong> <code>object</code> oder <code>function</code>. Wird versucht, eine Funktion an einen anderen Wert zu binden, wird dieser Wert in ein Objekt gecastet. Aus <code>1</code> wird also <code>new Number(1)</code>. Diese Objekt-Varianten von simplen Datentypen werden von JavaScript intern immer wieder verwendet, wenn dies notwendig ist. Als JS-Entwickler braucht man sich aber nicht weiter darum kümmern, da es keine nennenswerten Auswirkungen hat.</p></div></article></main></div><script src=/js/index.js type=module></script></body></html>