<!doctype html><html lang=de><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linnert Media</title><meta name=theme-color content="#155E75"><link rel=manifest href=/manifest.webmanifest><link rel="shortcut icon" href=/appicons/appicon-16.png sizes=16x16 type=image/png><link rel="shortcut icon" href=/appicons/appicon-32.png sizes=32x32 type=image/png><link rel=icon href=/favicon.ico type=image/x-icon><link rel=stylesheet href=https://linnertmedia.de/css/main.min.7c941dbc5e2c547f00dabc9d3922b2d4b7069d5f6bbe794d05dabe8db810aa25ed573e51d6b25ff480f0fa121b4552624032721eb53618af38e3b110b57a4d7b.css integrity="sha512-fJQdvF4sVH8A2rydOSKy1LcGnV9rvnlNBdq+jbgQqiXtVz5R1rJf9IDw+hIbRVJiQDJyHrU2GK8447EQtXpNew==" crossorigin=anonymous></head><body><div class="min-h-screen dark:bg-gray-700"><div class="py-4 lg:py-3 bg-brand-700 text-white sticky sm:static top-0 z-40 dark:bg-gray-800"><div class="max-w-3xl mx-auto px-4 flex items-center justify-center"><a href=https://linnertmedia.de class="font-heading text-2xl lg:text-lg tracking-widest uppercase"><span class="text-brand-200 relative -top-1">Linnert</span><span class="text-brand-50 relative -bottom-1">Media</span></a><div class="hidden sm:hidden ml-auto text-brand-50 hover:text-brand-200"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></div><nav class="ml-auto flex gap-6 sm:fixed sm:bottom-0 sm:left-0 sm:right-0 md:flex sm:z-50"><ul class="list-none grid grid-flow-col auto-cols-max sm:auto-cols-fr gap-x-1 sm:gap-x-0 md:flex-grow sm:bg-gray-100 sm:border-t sm:border-gray-300 sm:dark:bg-gray-800 sm:dark:border-gray-500"><li class="sm:flex-grow sm:text-center"><a href=/ class="text-brand-50
sm:block sm:py-2 sm:text-xs
outline-none
px-3 py-2
rounded
dark:focus:bg-gray-900
hover:text-brand-100
dark:text-gray-50
dark:hover:text-gray-200
sm:focus:bg-gray-200
sm:p-0
<!-- Light -->
sm:text-gray-500
sm:hover:text-gray-600
<!-- Dark -->
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg></div><span>Beiträge</span></a></li><li class="sm:flex-grow sm:text-center"><a href=/projekte/ class="text-brand-50
sm:block sm:py-2 sm:text-xs
outline-none
px-3 py-2
rounded
dark:focus:bg-gray-900
hover:text-brand-100
dark:text-gray-50
dark:hover:text-gray-200
sm:focus:bg-gray-200
sm:p-0
<!-- Light -->
sm:text-gray-500
sm:hover:text-gray-600
<!-- Dark -->
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-code"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div><span>Projekte</span></a></li><li class="sm:flex-grow sm:text-center"><a href=/info/ class="text-brand-50
sm:block sm:py-2 sm:text-xs
outline-none
px-3 py-2
rounded
dark:focus:bg-gray-900
hover:text-brand-100
dark:text-gray-50
dark:hover:text-gray-200
sm:focus:bg-gray-200
sm:p-0
<!-- Light -->
sm:text-gray-500
sm:hover:text-gray-600
<!-- Dark -->
sm:dark:text-gray-400
sm:dark:hover:text-gray-50"><div class="hidden sm:flex justify-center pb-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-info"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg></div><span>Infos</span></a></li></ul></nav></div></div><main class="max-w-3xl mx-auto pb-20"><article class=mt-8><h1 class="font-heading text-3xl mb-2 px-4 dark:text-gray-50">Die Grundlagen zu Node.js</h1><div class="mb-8 mx-4"><div class="text-sm md:text-xs flex"><div class="text-gray-500 dark:text-gray-400">16. June 2018</div><a href=/tags/javascript class="link--default ml-4">JavaScript</a>
<a href=/tags/node.js class="link--default ml-4">Node.JS</a></div></div><div class="px-4 text-gray-700 prose prose-lg dark:prose-dark max-w-none"><p>Node.js ist inzwischen allgegenwärtig in der Welt der Web-Entwicklung. Einige kennen es aber vielleicht nur im Kontext von JavaScript-Server-Anwendungen. Dieser Artikel soll einen groben Überblick über alle Facetten von Node.js geben.</p><h2 id=allgemeine-informationen>Allgemeine Informationen</h2><p>Node.js ist eine Plattform, die es erlaubt, JavaScript-Code außerhalb eines Web-Browsers auszuführen. Die aktuellen Versionen verwenden <em>V8</em> (Die JavaScript-Engine von Googles Browser <em>Chrome</em>) zum Ausführen von JavaScript-Code. Da V8 nur relativ begrenzte Möglichkeiten bietet, stehen einem des Weiteren noch native APIs zur Verfügung, um beispielsweise auf das lokale Dateisystem oder den Netzwerkverkehr zugreifen zu können.</p><p>Dadurch eröffnen sich nun einige Möglichkeiten und Einsatzgebiete. Der Bekannteste darunter ist die Entwicklung von Web-Anwendungs-Servern. Sei es zur Erstellung von HTML-Seiten oder zur Bereitstellung einer REST- oder GraphQL-API. Ein wichtiger Unterschied zu PHP ist hier allerdings, dass kein zusätzlicher Webserver wie Apache notwendig ist, denn Node.js selbst ist bereits der Server. Da man somit quasi seinen eigenen Server baut, hat man auch etwas mehr Freiheiten als mit Fertigpaketen wie Apache.</p><p>Weitere Einsatzzwecke sind das Erstellen von Kommandozeilen-Skripten und die Verwendung als Build-Tool für eigene Projekte. Nach der Installation auf einem Rechner stehen drei neue Befehle in der Kommandozeile zur Verfügung: <code>node</code>, <code>npm</code> und <code>npx</code>.</p><h2 id=der-node-befehl>Der <code>node</code>-Befehl</h2><p>Mit dem Befehl <code>node</code> lassen sich <code>.js</code>-Dateien ausführen, aber auch eine interaktive JavaScript-Konsole starten. Letztere startet man einfach durch ausführen von <code>node</code> in der Kommandozeile. Gibt man als Parameter allerdings eine JavaScript-Datei an, so wird der Code in dieser Datei ausgeführt. Führt man also den Befehl <code>node my-script.js</code> aus — und geht davon aus, dass diese Datei existiert und den Code <code>console.log('Hallo Welt')</code> enthält — dann wird &ldquo;Hallo Welt&rdquo; in der Kommandozeile ausgegeben.</p><p>Unter Linux und Unix kann man sogar einen Schritt weitergehen und Skripte erstellen, die sich wie übliche Bash-Skripte starten lassen (<code>./my-script.js</code>). Dazu muss die JavaScript-Datei in der ersten Zeile folgendes beinhalten: <code>#!/usr/bin/env node</code>.</p><p>Dadurch lassen sich einerseits Skripte erstellen, die einen endlichen Job erledigen und irgendwann fertig sind — z. B. Dateien kopieren. Oder aber es wird ein Dienst gestartet, der permanent im Hintergrund läuft und auf Verbindungen oder Anfragen wartet.</p><h2 id=neue-projekte-anlegen-mit-npm-init-und-packagejson>Neue Projekte anlegen mit <code>npm init</code> und <code>package.json</code></h2><p>Npm ist die in Node.js integrierte Paketverwaltung. Damit lassen sich Projekte erstellen und dessen Abhängigkeiten verwalten. In der Regel beginnt man damit, dass man in einem Ordner ein Npm-Projekt initialisiert. Das geschieht in der Regel im Hauptverzeichnis des Projekts, an dem man arbeitet, mit folgendem Befehl: <code>npm init</code>. Danach werden einem einige Fragen zum Projekt gestellt: Name, Version, Autor, Lizenz etc. Die muss man nicht sofort und absolut gewissenhaft beantworten, denn ein späteres Ändern der Daten ist sehr einfach möglich.</p><p>Nachdem das Projekt initialisiert wurde, findet man im Projektverzeichnis eine neue Datei: <code>package.json</code>. Diese beinhaltet alle vorhin eingegebenen Daten. Mehr ist dabei auch nicht passiert. Man kann diese Datei alternativ also auch per Hand erstellen. Diese Datei umfasst alle Informationen zum aktuellen Projekt und lässt sich als Dreh- und Angelpunkt dessen sehen. Ein händisches Editieren der Datei ist problemlos möglich und stellenweise sogar erforderlich.</p><h2 id=pakete-installieren-mit-npm-install>Pakete installieren mit <code>npm install</code></h2><p>In der <code>package.json</code> befinden sich u. a. die Felder <code>dependencies</code> und <code>devDependencies</code>. Diese listen die Pakete auf, die vom aktuellen Projekt benötigt werden, damit das Projekt lauffähig ist. Unter <a href=https://npmjs.org>npmjs.org</a> kann man sich einen Überblick über alle verfügbaren Pakete verschaffen.</p><p>Die beiden Felder unterscheiden sich dabei nur darin, dass <code>devDependencies</code> alle Pakete beinhaltet, die zur Entwicklung am Projekt notwendig sind. <code>dependencies</code> listet alle Pakete auf, die zur generellen Funktionalität des Projekts notwendig sind. <code>devDependencies</code> beinhaltet also je nach Art des Projekts beispielsweise Entwicklerwerkzeuge wie Linter, Test-Tools, TypeScript-Definitionen und ähnliches.</p><p>Möchten wir jetzt ein neues Paket installieren, bewegen wir uns in der Kommandozeile erst einmal in das Verzeichnis, das die <code>package.json</code> beinhaltet. Dann führen wir den Befehl <code>npm install &lt;name-of-package></code> aus, wobei <code>&lt;name-of-package></code> der Name des Pakets ist, das wir installieren möchten. Installieren wir beispielsweise das Framework <em>Vue</em> würde das so aussehen: <code>npm install vue</code>. Der exakte Name des Paketes ist in der Regel in der Dokumentation der Bibliothek zu finden, oder direkt unter <a href=https://npmjs.org>npmjs.org</a>.</p><p>Was passiert nun bei der Installation? Alle installierten Pakete landen im Ordner <code>node_modules</code>, der neben unserer <code>package.json</code> angelegt wird, sollte er noch nicht existieren. Außerdem wird dieses Paket in der <code>package.json</code> im Feld <code>dependencies</code> automatisch hinterlegt. Das hat folgenden Vorteil: Bei der Verwendung einer Versionskontrolle wie Git brauchen wir den Inhalt von <code>node_modules</code> nicht mit unter Versionierung stellen. Checkt man das Projekt frisch aus und hat lediglich die <code>package.json</code>, reicht ein einfaches <code>npm install</code> und es werden automatisch alle Pakete erneut installiert, die in der <code>package.json</code> unter <code>dependencies</code> (und <code>devDependencies</code>) aufgelistet sind.</p><h2 id=skripte-ausführen-mit-npm-run>Skripte ausführen mit <code>npm run</code></h2><p>In der <code>package.json</code> befindet sich auch ein Feld <code>scripts</code>. Dies beinhaltet eine Liste selbstdefinierter Skripte, die man immer wieder braucht. Npm hilft einem auch dabei, häufig benötigte Skripte schneller und einfacher ausführen zu können. Ein Skript definiert man, indem man dem <code>scripts</code>-Objekt ein Key-Value-Paar hinzufügt. Der „key“ ist dabei der Name des Skripts, der „value“ das Skript, das dann letzten Endes ausgeführt wird.</p><div class="font-mono font-semibold text-sm px-4 py-2 bg-gray-100 text-gray-500 inline-block rounded-t
lg:ml-4
md:ml-0 md:text-xs
dark:bg-gray-800 dark:text-gray-400">package.json</div><div class=codeblock><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
	<span class=err>/*</span> <span class=err>...</span> <span class=err>*/</span>
	<span class=nt>&#34;scripts&#34;</span><span class=p>:</span> <span class=p>{</span>
		<span class=nt>&#34;build&#34;</span><span class=p>:</span> <span class=s2>&#34;webpack -p&#34;</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></div></div><p>Im Grunde können die Skripte alles enthalten, was man auch in der Kommandozeile schreiben kann. Zusätzlich jedoch können ohne Umwege Skripte aufgerufen werden, die über Npm installiert wurden. Stellt ein <strong>lokal und nicht global</strong> installiertes Paket einen Kommandozeilenbefehl zur Verfügung (wie es zum Beispiel bei <code>webpack</code> der Fall ist), wäre dieser üblicherweise über <code>./node_modules/.bin/webpack</code> verfügbar. Diese umständliche Pfadangabe ist im <code>scripts</code>-Teil der <code>package.json</code> nicht notwendig. Es reicht ein einfaches <code>webpack</code>.</p><h2 id=skripte-ausführen-mit-npx>Skripte ausführen mit <code>npx</code></h2><p>Npx ist neu mit Npm 5.0 hinzugekommen. Es vereinfacht das Ausführen von Kommandozeilenbefehlen, die durch Npm installiert wurden ungemein. Seitdem lässt sich das oben genannte Beispiel <code>./node_modules/.bin/webpack</code> durch <code>npx webpack</code> abkürzen. (In der <code>package.json</code> ist es aber weiterhin nicht notwendig)</p><p>Wird versucht, durch Npx einen Befehl auszuführen, der nicht existiert, wird automatisch das jeweilige Skript temporär via Npm installiert und anschließend ausgeführt. Dies ist vor allem dann hilfreich, wenn man einen Befehl nur ausprobieren möchte oder ihn nur sehr selten benötigt — zum Beispiel <code>yo</code> von <a href=http://yeoman.io/><em>Yeoman</em></a>.</p><h2 id=pakete-global-installieren-mit-npm-install---global>Pakete global installieren mit <code>npm install --global</code></h2><p>Die Möglichkeit, Pakete global auf dem System zu installieren, gerät mit der Zeit immer mehr in den Hintergrund. Durch Npx ist es einerseits nicht mehr notwendig, andererseits wird es an einigen Stellen empfohlen, Skripte im Projektkontext statt global zu installieren.</p><p>Einen interessanten Einsatzzweck hat die globale Installation von Paketen aber dennoch: Das Entwickeln von systemunabhängigen Kommandozeilenskripten, die die Arbeit mit der Kommandozeile vereinfachen sollen. Ein global installiertes Paket ergibt nur dann Sinn, wenn es einen Befehl für die Kommandozeile bereitstellt, der in vielen Ordnern einsetzbar ist. Ein Beispiel wäre <a href=https://github.com/DeMille/bookmark>bookmark</a>, ein kleines Kommandozeilen-Werkzeug, mit dem man Ordner als Lesezeichen anlegen kann, um schneller dorthin navigieren zu können.</p><h2 id=node-mit-chakracore>Node mit ChakraCore</h2><p>Aktuell arbeitet Microsoft auch an einer Version von Node.js mit ChakraCore statt V8. ChakraCore ist die JavaScript-Engine des Browsers Edge. Man kann diese Version in Form einer Vorschau-Version ausprobieren. Der Quellcode ist auf <a href=https://github.com/nodejs/node-chakracore>GitHub</a> zu finden.</p><h2 id=nodejs-und-wasm>Node.js und WASM</h2><p>Node.js wird in Zukunft mit <em>WASM</em> (WebAssembly) vermutlich noch etwas mehr an Bedeutung und Vielfältigkeit gewinnen. WASM, kurz erklärt, ist ein compile target für allerlei Programmiersprachen. WASM verwendet dabei die Laufzeitumgebung, die auch von JavaScript verwendet wird, allerdings wird beim Kompiliervorgang quasi an JavaScript &ldquo;vorbeikompiliert&rdquo;. Dadurch ist für WASM kompilierter Programmcode sehr performant. Da Node.js eine Plattform ist, die auf einer Unzahl von Plattformen lauffähig ist, gilt das auch für WASM-Programme.</p><p>Unterm Strich erlaubt dies das Entwickeln von performanter Software in einer beliebigen Programmiersprache, die überall dort lauffähig ist, wo man eine WASM-kompatible JavaScript-Engine vorfindet. Das heißt konkret: Jede Plattform, auf der Node.js lauffähig ist und auch jeder aktuelle Web-Browser. Die aktuell primär unterstützten Sprachen sind C/C++ und Rust von Mozilla. Weitere Sprachen werden bald folgen. Darunter bekannte Sprachen, aber auch werden daraufhin neue Sprachen entstehen, die primär auf WASM abgestimmt sind, zum Beispiel <a href=https://github.com/AssemblyScript/assemblyscript>AssemblyScript</a> oder <a href=https://github.com/utatti/kou>Kou</a>.</p></div></article></main></div><script src=/js/index.js type=module></script></body></html>